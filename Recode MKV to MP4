# Recode MKV to MP4
# Version 1.9 (FFmpeg installed directly to Desktop for simplicity)
CLS
# Configuration Variables
$debugMode = $false  # Set to $true for verbose output
$loopSleepMs = 1000   # Reduced from 2500ms for better responsiveness
$finalSleepSeconds = 0  # Removed auto-exit; use Read-Host instead

# Define FFmpeg path and output directory
# FFmpeg will be installed directly to Desktop\ffmpeg-master-latest-win64-gpl-shared\bin\ffmpeg.exe
$desktopPath = [System.Environment]::GetFolderPath('Desktop')
$ffmpegInstallDir = Join-Path $desktopPath "ffmpeg-master-latest-win64-gpl-shared"
$ffmpegPath = Join-Path $ffmpegInstallDir "bin\ffmpeg.exe"
# Output videos to E:\ for portability
$outputPath = E:\

# Function to Download and Install FFmpeg
function Install-FFmpeg {
    param($downloadPath, $extractPath)
    Write-Host "Downloading FFmpeg to $downloadPath..." -ForegroundColor Yellow
    try {
        $releasePage = Invoke-WebRequest -Uri "https://github.com/btbn/ffmpeg-builds/releases" -UseBasicParsing -ErrorAction Stop
        $latestRelease = $releasePage.Links | Where-Object { $_.href -match "releases/download/.*ffmpeg-master-latest-win64-gpl-shared.*\.zip" } | Select-Object -First 1
        if ($latestRelease) {
            $downloadUrl = "https://github.com$($latestRelease.href)"
            $releaseTag = $latestRelease.href -replace '.*/releases/download/([^/]+)/.*', '$1'
            Write-Host "Downloading FFmpeg version: $releaseTag" -ForegroundColor Green
            
            # Download to specified path
            Invoke-WebRequest -Uri $downloadUrl -OutFile $downloadPath -ErrorAction Stop
            if ($debugMode) { Write-Host "Download completed: $downloadPath" -ForegroundColor Green }
            
            # Ensure extract path exists (parent directory)
            $extractParent = Split-Path $extractPath -Parent
            if (-not (Test-Path $extractParent)) {
                New-Item -ItemType Directory -Path $extractParent -Force | Out-Null
                if ($debugMode) { Write-Host "Created extraction parent directory: $extractParent" -ForegroundColor Green }
            }
            
            # Extract to specified path
            Write-Host "Extracting FFmpeg to $extractPath..." -ForegroundColor Yellow
            try {
                Expand-Archive -Path $downloadPath -DestinationPath $extractParent -Force -ErrorAction Stop
                if ($debugMode) { Write-Host "Extraction completed successfully." -ForegroundColor Green }
            } catch {
                Write-Host "ERROR: Failed to extract FFmpeg. Error: $($_.Exception.Message)" -ForegroundColor Red
                Write-Host "Please manually extract $downloadPath to $extractParent." -ForegroundColor Yellow
                return $false
            }
            
            # Verify extraction
            if (Test-Path $ffmpegPath) {
                Write-Host "FFmpeg installed successfully to $ffmpegPath." -ForegroundColor Green
            } else {
                Write-Host "ERROR: FFmpeg executable not found after extraction in $ffmpegPath." -ForegroundColor Red
                return $false
            }
            
            # Clean up zip file only after successful extraction
            if (Test-Path $downloadPath) {
                try {
                    Remove-Item -Path $downloadPath -Force -ErrorAction Stop
                    if ($debugMode) { Write-Host "Cleaned up zip file: $downloadPath" -ForegroundColor Green }
                } catch {
                    Write-Host "WARNING: Failed to delete zip file $downloadPath. Error: $($_.Exception.Message)" -ForegroundColor Yellow
                }
            }
        } else {
            Write-Host "ERROR: Could not find FFmpeg release on GitHub." -ForegroundColor Red
            return $false
        }
    } catch {
        Write-Host "ERROR: Failed to download FFmpeg. Error: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "You may need to manually download FFmpeg from https://github.com/btbn/ffmpeg-builds/releases and extract it to $extractParent." -ForegroundColor Yellow
        return $false
    }
    return $true
}

# FFmpeg Update Check
Write-Host "Checking for FFmpeg installation..." -ForegroundColor Yellow
try {
    # Check if FFmpeg exists
    if (-not (Test-Path -Path $ffmpegPath -PathType Leaf)) {
        Write-Host "FFmpeg not found at $ffmpegPath." -ForegroundColor Yellow
        Write-Host "Would you like to download and install FFmpeg to the Desktop? (Y/N)" -ForegroundColor Cyan
        $response = Read-Host
        
        if ($response -eq 'Y' -or $response -eq 'y') {
            $zipPath = Join-Path $desktopPath "ffmpeg-latest.zip"
            if (Install-FFmpeg -downloadPath $zipPath -extractPath $ffmpegInstallDir) {
                Write-Host "FFmpeg installed successfully to $ffmpegPath." -ForegroundColor Green
            } else {
                Write-Host "ERROR: FFmpeg installation failed. Exiting." -ForegroundColor Red
                Read-Host "Press Enter to exit..."
                exit
            }
        } else {
            Write-Host "ERROR: FFmpeg is required to run this script. Exiting." -ForegroundColor Red
            Read-Host "Press Enter to exit..."
            exit
        }
    } else {
        # FFmpeg exists, check for updates
        Write-Host "FFmpeg found at $ffmpegPath. Checking for updates..." -ForegroundColor Yellow
        $currentVersion = & $ffmpegPath -version 2>$null | Select-String "ffmpeg version" | ForEach-Object { $_ -replace '.*ffmpeg version ([^ ]+).*', '$1' }
        if (-not $currentVersion) {
            Write-Host "WARNING: Could not determine current FFmpeg version. Assuming update is needed." -ForegroundColor Yellow
            $currentVersion = "unknown"
        }
        $releasePage = Invoke-WebRequest -Uri "https://github.com/btbn/ffmpeg-builds/releases" -UseBasicParsing -ErrorAction Stop
        $latestRelease = $releasePage.Links | Where-Object { $_.href -match "releases/download/.*ffmpeg-master-latest-win64-gpl-shared.*\.zip" } | Select-Object -First 1
        if ($latestRelease) {
            $downloadUrl = "https://github.com$($latestRelease.href)"
            $releaseTag = $latestRelease.href -replace '.*/releases/download/([^/]+)/.*', '$1'
            Write-Host "Latest FFmpeg version found: $releaseTag" -ForegroundColor Green
            
            if ($currentVersion -ne $releaseTag) {
                Write-Host "Current FFmpeg version: $currentVersion" -ForegroundColor Yellow
                Write-Host "Update available. Download and install $releaseTag to the Desktop? (Y/N)" -ForegroundColor Cyan
                $response = Read-Host
                
                if ($response -eq 'Y' -or $response -eq 'y') {
                    # Attempt to terminate any running FFmpeg processes
                    Write-Host "Checking for running FFmpeg processes..." -ForegroundColor Yellow
                    $ffmpegProcesses = Get-Process -Name "ffmpeg" -ErrorAction SilentlyContinue
                    if ($ffmpegProcesses) {
                        Write-Host "Terminating running FFmpeg processes..." -ForegroundColor Yellow
                        $ffmpegProcesses | ForEach-Object { Stop-Process -Id $_.Id -Force -ErrorAction SilentlyContinue }
                        Start-Sleep -Seconds 2  # Give processes time to terminate
                    }
                    
                    # Attempt to delete old FFmpeg directory with retry
                    if (Test-Path $ffmpegInstallDir) {
                        Write-Host "Removing old FFmpeg installation..." -ForegroundColor Yellow
                        $retryCount = 3
                        $success = $false
                        for ($i = 1; $i -le $retryCount; $i++) {
                            try {
                                Remove-Item -Path $ffmpegInstallDir -Recurse -Force -ErrorAction Stop
                                $success = $true
                                Write-Host "Successfully removed old FFmpeg directory." -ForegroundColor Green
                                break
                            } catch {
                                Write-Host "Attempt $i/${retryCount}: Failed to remove FFmpeg directory. Error: $($_.Exception.Message)" -ForegroundColor Red
                                Start-Sleep -Seconds 2
                            }
                        }
                        if (-not $success) {
                            Write-Host "WARNING: Could not remove old FFmpeg directory. Proceeding with download, but you may need to manually delete $ffmpegInstallDir later." -ForegroundColor Yellow
                        }
                    }
                    
                    # Download and install new version
                    $zipPath = Join-Path $desktopPath "ffmpeg-$releaseTag.zip"
                    if (Install-FFmpeg -downloadPath $zipPath -extractPath $ffmpegInstallDir) {
                        Write-Host "FFmpeg updated successfully to $releaseTag" -ForegroundColor Green
                    } else {
                        Write-Host "ERROR: FFmpeg update failed. Continuing with existing version." -ForegroundColor Yellow
                    }
                } else {
                    Write-Host "Skipping FFmpeg update." -ForegroundColor Yellow
                }
            } else {
                Write-Host "FFmpeg is up to date (version: $currentVersion)." -ForegroundColor Green
            }
        } else {
            Write-Host "Could not find FFmpeg release on GitHub." -ForegroundColor Red
        }
    }
} catch {
    Write-Host "ERROR: Failed to check for FFmpeg updates. Error: $($_.Exception.Message)" -ForegroundColor Red
}
Write-Host "Continuing with conversion process..." -ForegroundColor Yellow
Start-Sleep -Seconds 2

# FFmpeg Encoding Parameters
$preset = "fast"
$crf = 28
$audioBitrate = "256k"

# Dynamic Thread and Concurrency Settings
$concurrentJobs = 1
$availableThreads = (Get-WmiObject -Class Win32_Processor).NumberOfLogicalProcessors
$folderThreads = [Math]::Max(4, [Math]::Floor($availableThreads * 0.95))  # 95% of logical processors for folder mode
$singleFileThreads = [Math]::Max(4, [Math]::Floor($availableThreads * 0.95))  # 95% for single file

# Error Log Path
$errorLog = Join-Path $outputPath "conversion_errors.txt"

# FFmpeg Path Validation
if (-not (Test-Path -Path $ffmpegPath -PathType Leaf)) {
    Write-Host "ERROR: ffmpeg.exe not found at the specified path: $ffmpegPath" -ForegroundColor Red
    Write-Host "Would you like to download and install FFmpeg to the Desktop? (Y/N)" -ForegroundColor Cyan
    $response = Read-Host
    
    if ($response -eq 'Y' -or $response -eq 'y') {
        $zipPath = Join-Path $desktopPath "ffmpeg-latest.zip"
        if (Install-FFmpeg -downloadPath $zipPath -extractPath $ffmpegInstallDir) {
            Write-Host "FFmpeg installed successfully to $ffmpegPath." -ForegroundColor Green
        } else {
            Write-Host "ERROR: FFmpeg installation failed. Exiting." -ForegroundColor Red
            Read-Host "Press Enter to exit..."
            exit
        }
    } else {
        Write-Host "ERROR: FFmpeg is required to run this script. Exiting." -ForegroundColor Red
        Read-Host "Press Enter to exit..."
        exit
    }
}

# Create output directory if it doesn't exist
if (-not (Test-Path -Path $outputPath)) {
    New-Item -ItemType Directory -Path $outputPath -Force | Out-Null
}

# Function: Get Trimmed Name
function Get-TrimmedName {
    param($fileName)
    $baseName = [System.IO.Path]::GetFileNameWithoutExtension($fileName)
    if ($baseName -match "^(.*?)\.?(\d{4})") {
        $namePart = $matches[1].Replace('.', ' ').Trim()
        return "$namePart ($($matches[2]))"
    } else {
        return $baseName.Replace('.', ' ').Trim()
    }
}

# Function: Launch FFmpeg Job
function Launch-FfmpegJob {
    param($inputFile, [ref]$runningJobs)
    
    $trimmedName = Get-TrimmedName $inputFile
    $outputBaseName = "${trimmedName}"
    $outputFile = Join-Path $outputPath "${outputBaseName}.mp4"
    $threadCount = if ($choice -eq 's') { $singleFileThreads } else { $folderThreads }
    
    $ffmpegArgs = "-y -i `"$inputFile`" -map 0:v:0 -map 0:a:0 -c:v libx264 -threads $threadCount -preset `"$preset`" -crf $crf -c:a aac -b:a `"$audioBitrate`" -ar 48000 -ac 2 -profile:a aac_low -movflags faststart `"$outputFile`""
    
    if ($debugMode) {
        Write-Host "Preparing to launch for: $inputFile" -ForegroundColor Yellow
        Write-Host "FFmpeg Command Line: `"$ffmpegPath`" $ffmpegArgs" -ForegroundColor DarkGray
    }
    
    try {
        $launchedProc = Start-Process -FilePath $ffmpegPath -ArgumentList $ffmpegArgs -WindowStyle Normal -PassThru -ErrorAction Stop
        $runningJobs.Value[$launchedProc.Id] = @{
            File = $inputFile
            Output = $outputFile
            StartTime = Get-Date
        }
        if ($debugMode) {
            Write-Host "Launched process with PID: $($launchedProc.Id)" -ForegroundColor Green
        }
    } catch {
        Write-Host "ERROR: Failed to launch FFmpeg for $inputFile. Error: $($_.Exception.Message)" -ForegroundColor Red
        Add-Content $errorLog "Failed Launch: $inputFile - Error: $($_.Exception.Message)"
    }
}

# Function: Monitor Jobs
function Monitor-Jobs {
    param([ref]$runningJobs)
    
    foreach ($jobPid in @($runningJobs.Value.Keys)) {
        $proc = Get-Process -Id $jobPid -ErrorAction SilentlyContinue
        if (-not $proc -or $proc.HasExited) {
            $jobInfo = $runningJobs.Value[$jobPid]
            $inputFile = $jobInfo.File
            $outputFile = $jobInfo.Output
            
            if ($proc -and $proc.ExitCode -eq 0) {
                # Validate output file exists
                if (Test-Path $outputFile) {
                    Write-Host "SUCCESS: Conversion completed for $inputFile." -ForegroundColor Green
                } else {
                    Write-Host "WARNING: Conversion reported success but output file missing for $inputFile." -ForegroundColor Yellow
                    Add-Content $errorLog "Missing Output: $inputFile"
                }
            } elseif ($proc) {
                Write-Host "ERROR: Conversion failed for $inputFile. Exit Code: $($proc.ExitCode)." -ForegroundColor Red
                Add-Content $errorLog "Failed: $inputFile - Code: $($proc.ExitCode)"
                # Optional: Delete partial output
                if (Test-Path $outputFile) { Remove-Item $outputFile -Force }
            } else {
                Write-Host "INFO: Process for $inputFile not found (likely exited)." -ForegroundColor DarkYellow
            }
            
            $runningJobs.Value.Remove($jobPid)
            if ($debugMode) {
                Write-Host "Removed PID $jobPid. Remaining jobs: $($runningJobs.Value.Count)" -ForegroundColor DarkGreen
            }
        }
    }
}

# UI: Mode Selection Form
Add-Type -AssemblyName System.Windows.Forms
$form = New-Object System.Windows.Forms.Form
$form.Text = "Choose Conversion Input"
$form.Size = New-Object System.Drawing.Size(500,150)
$form.StartPosition = "CenterScreen"
$form.TopMost = $true
$form.Add_Load({ $form.Activate() })

$buttonSingle = New-Object System.Windows.Forms.Button
$buttonSingle.Text = "Select Single File"
$buttonSingle.Size = New-Object System.Drawing.Size(120,40)
$buttonSingle.Location = New-Object System.Drawing.Point(50,40)
$buttonSingle.Add_Click({ $script:choice = 's'; $form.Close() })

$buttonFolder = New-Object System.Windows.Forms.Button
$buttonFolder.Text = "Select Folder"
$buttonFolder.Size = New-Object System.Drawing.Size(120,40)
$buttonFolder.Location = New-Object System.Drawing.Point(180,40)
$buttonFolder.Add_Click({ $script:choice = 'f'; $form.Close() })

$buttonCancel = New-Object System.Windows.Forms.Button
$buttonCancel.Text = "Cancel"
$buttonCancel.Size = New-Object System.Drawing.Size(120,40)
$buttonCancel.Location = New-Object System.Drawing.Point(310,40)
$buttonCancel.Add_Click({ $script:choice = $null; $form.Close() })

$form.Controls.Add($buttonSingle)
$form.Controls.Add($buttonFolder)
$form.Controls.Add($buttonCancel)
$form.ShowDialog()

if (-not $choice) {
    Write-Host "No selection made. Exiting."
    exit
}

# File/Folder Selection
$recurse = $true  # TODO: Add UI option to toggle recurse if desired
if ($choice -eq 's') {
    $fileDialog = New-Object System.Windows.Forms.OpenFileDialog
    $fileDialog.InitialDirectory = $desktopPath
    $fileDialog.Filter = "Video files (*.mp4;*.mkv;*.avi)|*.mp4;*.mkv;*.avi"
    $fileDialog.Multiselect = $false
    if ($fileDialog.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
        $inputFiles = @($fileDialog.FileName)
    } else {
        Write-Host "No file selected. Exiting."
        exit
    }
} elseif ($choice -eq 'f') {
    $folderDialog = New-Object System.Windows.Forms.FolderBrowserDialog
    $folderDialog.SelectedPath = $desktopPath
    if ($folderDialog.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
        $params = @{
            Path = $folderDialog.SelectedPath
            Include = '*.mp4', '*.mkv', '*.avi'
        }
        if ($recurse) { $params.Recurse = $true }
        $inputFiles = @(Get-ChildItem @params | Select-Object -ExpandProperty FullName | Sort-Object { (Get-Item $_).Length })  # Sort by size ascending
    } else {
        Write-Host "No folder selected. Exiting."
        exit
    }
}

if ($inputFiles.Count -eq 0) {
    Write-Host "No video files found. Exiting."
    exit
}

# Initialize Queue and Job Tracking
$pendingFiles = [System.Collections.Queue]::new($inputFiles)
$runningJobs = @{}  # Hashtable: PID -> JobInfo

if ($debugMode) {
    Write-Host "Starting main processing loop..." -ForegroundColor Yellow
}

# Main Processing Loop
while ($pendingFiles.Count -gt 0 -or $runningJobs.Count -gt 0) {
    if ($debugMode) {
        Write-Host "`n=======================================================" -ForegroundColor Cyan
        Write-Host "Loop Iteration Start: $(Get-Date -Format 'HH:mm:ss.fff')" -ForegroundColor Cyan
        Write-Host "Pending files: $($pendingFiles.Count), Running jobs: $($runningJobs.Count)" -ForegroundColor Cyan
    }
    
    $maxConcurrentJobs = if ($choice -eq 's') { 1 } else { $concurrentJobs }
    
    # Launch New Jobs
    while ($runningJobs.Count -lt $maxConcurrentJobs -and $pendingFiles.Count -gt 0) {
        if ($debugMode) { Write-Host "`n--- Launch Condition Met ---" -ForegroundColor Green }
        
        $inputFile = $pendingFiles.Dequeue()
        Launch-FfmpegJob -inputFile $inputFile -runningJobs ([ref]$runningJobs)
        
        Start-Sleep -Milliseconds 500  # Reduced post-launch sleep
    }
    
    # Monitor Completed Jobs
    Monitor-Jobs -runningJobs ([ref]$runningJobs)
    
    # Loop Pause
    Start-Sleep -Milliseconds $loopSleepMs
    # Removed CLS to preserve output
}

Write-Host "`n=======================================================" -ForegroundColor White
Write-Host "All files processed." -ForegroundColor Green
Read-Host "Press Enter to exit..."
